/*
  //create a tree of vnodes

  //maybe I should define special behavior to create the root vnode
  
  struct vnode *new_vnode = (*vnode)(malloc(sizeof(vnode)));
  struct vnode *last_vn = NULL;
  int last_inode_idx;
  struct vdir_entry dir_content;
  int mem_ptr = INODE_OFFSET;
  while (mem_ptr < DATA_OFFSET) {
    //check if inode is a dir
    if (current_inode.type == 0) {
      //get each file and dir, set the parent to the inode
      int read_bytes = 0;
      int idx = 0;
      int table_ptr = current_inode[0]*BLOCK_SIZE+DATA_OFFSET;
      int table_end = table_ptr+BLOCK_SIZE;
      for (int i = 0; i < N_DBLOCKS; i++) {
        if (read_bytes >= current_inode.size()) {
          break;
        }
        table_ptr = current_inode[i]*BLOCK_SIZE+DATA_OFFSET;
        memcpy(mem_buffer, &dir_content, sizeof(vdir_entry));
        //create a new vnode
        vnode *new_vn = (*vnode)(malloc(sizeof(vnode))); 
        new_vn->vnode_number = next_vnode;
        next_vnode++;
        strcpy(dir_content->name , new_vn, sizeof(256));
        new_vn->parent =  last_vn;
        new->vn.unixfs.inode = idx;
        last_vn = new_vn;
        read_bytes = read_bytes + sizeof(vdir_entry);
        idx++;
      }
      
    }
  }


  //initialize mem buffer
  // 
  int s_block_location = BLOCK_SIZE + mem_buffer;
  memcpy(s_block_location, s_block, sizeof(superblock));
  s_block->current_dir = 0; //we are currently in the root directory, which is the first inode
  */


  /*struct vnode current_dir = *vn;
  int mem_location = vnode.unifxfs.inode*BLOCK_SIZE+ INODE_OFFSET;
  
  struct vdir_entry dir_content;

  for (int i = 0; i < N_DBLOCKS; i++) {
    int mem_ptr = current_dir[i]*BLOCK_SIZE+DATA_OFFSET;
    int mem_end = mem_ptr+BLOCK_SIZE;

    //loop through the block
    while (mem_ptr < mem_end) {
      memcpy(&dir_content, mem_buffer, sizeof(vdir_entry));
      if (strcmp(dir_content.name, filename) == 0) {
        //the file was found
        return dir_content;
      }
      mem_ptr = mem_ptr+mem_end;
    }
  }

  for (int j = 0; j < N_IBLOCKS; j++) {
    int table_ptr = current_dir[i]*BLOCK_SIZE+DATA_OFFSET;
    int table_end = table_ptr+BLOCK_SIZE;

    //loop through the table
    while (table_ptr < table_end) {
      int block_idx = 0;
      memcpy(&block_idx,mem_buffer, sizeof(int));
      int block_ptr = block_idx*BLOCK_SIZE+DATA_OFFSET;
      int block_end = table_ptr+BLOCK_SIZE;
      while(block_ptr< block_end) {
        memcpy(&dir_content, mem_buffer, sizeof(vdir_entry));
        if (strcmp(dir_content.name, filename) == 0) {
          //the file was found
          return dir_content;
        }
        block_ptr = block_ptr+block_end;
      }
     
      table_ptr = table_ptr+table_end;
    }
  }
  */

  /*struct vnode current_dir;
  struct inode new_inode;
  struct vnode new_vnode;
  int mem_location = vnode.unifxfs.inode*BLOCK_SIZE+ INODE_OFFSET;
  
  struct vdir_entry dir_content = find_file(vn, filename, mem_buffer);
  
  if (vdir == NULL){
    //get the superblock free inode
    int new_inode_idx =s_block->free_inode
    int new_inode_ptr = new_inode_idx*BLOCK_SIZE+INODE_OFFSET;
    memcpy(mem_buffer, new_inode, sizeof(inode));
    s_block->free_inode = new_inode.next_inode;
    //write the new sblock to mem_buffer

    //create a new file inode
    //assign 10 free blocks to be dir blocks, 4 blocks to be indirect tables
    //write a new vdir_entry struct to the current directory inode
    //update the vnode system
  } else {
    //keep track that this is the open file.
  }
  */

  /*struct vnode current_file = *vn;
  if (current_file.inode.size > (10 * BLOCK_SIZE)) {

  } else {
    int block_idx = size/BLOCK_SIZE;
    int mem_ptr = block_idx*BLOCK_SIZE+DATA_OFFSET + size%BLOCK_SIZE;
    int mem_end = block_idx*BLOCK_SIZE+DATA_OFFSET + BLOCK_SIZE;
    int data_end = data+size;
    while(data < data_end) {
      for ( int i = mem_ptr)
      //more complex than this
      memcpy(mem_ptr, data, sizeof(data));
    }

  }*/


  //account for each element of the path
  char* token = strtok(path, "/"); // Split by "/"
  vdir_entry* table_entry;
  int found_dir = 0;
  int loop_idx = 0;
  //maybe this path should be done in steps, the shell seperates out the elements?
  while (token != NULL) {
        printf("Path element: %s\n", token);
        token = strtok(NULL, "/");
        
        while(found_dir == 0 && loop_idx)
        
  }

  else if (vn->type == 1) {
    for (int i = 0; i < vn->num_children; i++) {
      child_vn = vn->child_ptrs[i];
      if (strcmp(child_vn->name, (char*)filename) == 0) {
        open_file = child_vn;
      }
    }
  }

  /*for (int i = 0; i < N_DBLOCKS && children_read < new_vn->num_children; i++ ) {
      //find the entry of the child in the table
      mem_ptr = new_in.dblocks[i]*BLOCK_SIZE + DATA_OFFSET + mem_buffer;
      //copy the inode information to an entry struct
      table_entry = f_readdir(new_vn, mem_ptr);
      //build up the vnode tree under that child
      build_vnode_tree(root_vnode, NULL, table_entry->inode_idx);
      //log another dir table entry as read
      children_read++;
      free(table_entry);
  }*/


useful for finding a memory address
  /*if (new_location < N_DBLOCKS*BLOCK_SIZE) {
    int block_idx = new_location/BLOCK_SIZE;
    address = mem_buffer + DATA_OFFSET+current_in.dblocks[block_idx] + new_location%BLOCK_SIZE;
  } else {
    //check my work - what is table block
    int indirect_table_idx = (new_location - N_DBLOCKS*BLOCK_SIZE)/((BLOCK_SIZE/4)*BLOCK_SIZE);
    int offset_in_table = (new_location - N_DBLOCKS*BLOCK_SIZE)%((BLOCK_SIZE/4)*BLOCK_SIZE);
    int table_idx = (offset_in_table)/ BLOCK_SIZE;
    int indirect_table_block = current_in.iblocks[indirect_table_idx];
    //get the top of the table block
    char* mem_ptr = mem_buffer+DATA_OFFSET+ indirect_table_block*BLOCK_SIZE;
    //get the address in the table
    mem_ptr = mem_ptr + table_idx*4;
    int table_block;
    memcpy((void*)&table_block, (void*)mem_ptr, sizeof(int));

    //address is where I should be now
    address = mem_buffer + DATA_OFFSET  + offset_in_table+ table_block*BLOCK_SIZE;
  }*/
  printf("address %p\n", address);


  //use with fseek to actually move to a diven memory address
//given a location in data, return the address of that data
char* find_data_in_mem(vnode_t *vn, int s_data_offset, int end_data_offset ) {
  int bytes_read = 0;
  //if the ending offset is bigger than max file size
  if (end_data_offset > N_DBLOCKS*BLOCK_SIZE + N_IBLOCKS*(BLOCK_SIZE/4)*BLOCK_SIZE) {
    //the data to write is too big
  }

  int starting_block = s_data_offsets/BLOCK_SIZE;

  //get the inode of the vn
  char* mem_ptr = mem_buffer + INODE_OFFSET+ vn->inode*BLOCK_SIZE;
  struct inode current_in;
  memcpy((void*)&current_in, mem_ptr, sizeof(inode));

}

//At this point, I need to start allocating new blocks for tables and data
      for (int x = 0; x < N_IBLOCKS && bytes_written < end_bytes; x++) {
        //get the next free block
        int alloc_block = s_block.free_block;
        //update super block with the next free block
        mem_ptr = mem_buffer + DATA_OFFSET+alloc_block*BLOCK_SIZE;
        memcpy((void*)&s_block.free_block, mem_ptr, sizeof(int));
        
        //write to the indirect block of the current inode
        current_in.iblocks[x] = alloc_block;
        //char* ptr_table_block = mem_buffer + DATA_OFFSET + alloc_block * BLOCK_SIZE;

        //alloc a new block as a data block
        for (int y = 0; y < (BLOCK_SIZE/4) &&  bytes_written < end_bytes; y++) {
          int alloc_block = s_block.free_block;
          //update the just alloced indirect table with the alloced data block
          mem_ptr = mem_buffer+ DATA_OFFSET+ current_in.iblocks[x]*BLOCK_SIZE;
          mem_ptr = mem_ptr+ 4*y;
          memcpy(mem_ptr, (void*)&alloc_block, sizeof(int));
    
          //update super block with the next free block, which is stored in the just alloced block
          mem_ptr = mem_buffer + DATA_OFFSET+alloc_block*BLOCK_SIZE;
          memcpy((void*)&s_block.free_block, mem_ptr, sizeof(int));
        
          if (end_bytes - bytes_written < BLOCK_SIZE) {
            memcpy(mem_ptr,data,(end_bytes - bytes_written));
            bytes_written = bytes_written + (end_bytes - bytes_written);
          } else {
            memcpy(mem_ptr,data,BLOCK_SIZE);
            bytes_written = bytes_written + BLOCK_SIZE;
          }
        }
      }
    }


    /TODO: update the size of the inode
//TODO: make sure the offset of the open file gets updated
size_t f_write(vnode_t *vn, void *data, size_t size,int num, vfd_t fd)
{
  int bytes_written = 0;
  int end_bytes = open_file_pos + size*num;
  if (end_bytes > N_DBLOCKS*BLOCK_SIZE + N_IBLOCKS*(BLOCK_SIZE/4)*BLOCK_SIZE) {
    //the data to write is too big
  }
  int starting_block = open_file_pos/BLOCK_SIZE;

  //get the inode of the vn
  char* mem_ptr = mem_buffer + INODE_OFFSET+ vn->inode*BLOCK_SIZE;
  struct inode current_in;
  memcpy((void*)&current_in, mem_ptr, sizeof(inode));

  //starting in the direct blocks
  if (starting_block < N_DBLOCKS) {
    //write to fill any uneven offset
    int starting_offset = open_file_pos%BLOCK_SIZE;
    
    mem_ptr = mem_buffer + DATA_OFFSET+ starting_block*BLOCK_SIZE + starting_offset;

    int diff  = BLOCK_SIZE - starting_offset;
    if (diff > (end_bytes - bytes_written)) {
      diff = end_bytes - bytes_written;
    }

    memcpy(data, mem_ptr, sizeof(diff));
    bytes_written = bytes_written + diff;

    for (int i = (starting_block +1); i < N_DBLOCKS && bytes_written < end_bytes; i++) {
      mem_ptr = mem_buffer + DATA_OFFSET+ current_in.dblocks[i]*BLOCK_SIZE;
      memcpy(data, mem_ptr, sizeof(BLOCK_SIZE));
      bytes_written = bytes_written + diff;
    }

    //move to the indirect blocks. We need to alloc each indirect table and data block as we go
    if (bytes_written < end_bytes) {
      write_to_indirect_blocks(0, bytes_written, end_bytes, current_in, data);
    }
  // we write starting in the indirect blocks. At least one indirect block has been alloced.
  } else {
    //                          indirect bytes                        /  bytes stored per indirect table    
    int indirect_table_idx = (open_file_pos - N_DBLOCKS*BLOCK_SIZE) / ((BLOCK_SIZE/4)*BLOCK_SIZE);
    //                      indirect bytes                      % bytes stored per indirect table 
    int offset_in_table = (open_file_pos - N_DBLOCKS*BLOCK_SIZE) % ((BLOCK_SIZE/4)*BLOCK_SIZE);
    //if the table is not perfectly 
    //all bytes alloced over indirect table / bytes alloced per block
    int table_idx = (offset_in_table)/ BLOCK_SIZE;
    int indirect_table_block = current_in.iblocks[indirect_table_idx];

    //if there is a partially filled data block
    if (offset_in_table != 0) {
      int diff = BLOCK_SIZE -offset_in_table;
      //in case we dont need to move to a new block and can fill existing block
      if (diff > (end_bytes - bytes_written)) {
        diff = end_bytes - bytes_written;
      }

      //get the top of the table block
      char* mem_ptr = mem_buffer+DATA_OFFSET+ indirect_table_block*BLOCK_SIZE;
      //get the address in the table
      mem_ptr = mem_ptr + table_idx*4;

      //fill the partially filled block last alloced
      memcpy(mem_ptr, data, sizeof(diff));
      bytes_written = bytes_written + diff;
    }
    
    //if at least some data has already been alloced in this indirect table
    if (table_idx != 0 && offset_in_table != 0) {
      //fill the rest of the slots in the table - for each slot, alloc a new data block
      for (int j = table_idx; j < (BLOCK_SIZE/4) &&  bytes_written < end_bytes; j++) {
        int alloc_block = s_block.free_block;
        //update the indirect table with the block
        mem_ptr = mem_buffer+ DATA_OFFSET+ current_in.iblocks[indirect_table_idx]*BLOCK_SIZE;
        mem_ptr = mem_ptr+ 4*j;
        memcpy(mem_ptr, (void*)&alloc_block, sizeof(int));

        //update super block with the next free block
        mem_ptr = mem_buffer + DATA_OFFSET+alloc_block*BLOCK_SIZE;
        memcpy((void*)&s_block.free_block, mem_ptr, sizeof(int));
        //TODO:copy the new sblock to the disk
      
        if (end_bytes - bytes_written < BLOCK_SIZE) {
          memcpy(mem_ptr,data,(end_bytes - bytes_written));
          bytes_written = bytes_written + (end_bytes - bytes_written);
        } else {
          memcpy(mem_ptr,data,BLOCK_SIZE);
          bytes_written = bytes_written + BLOCK_SIZE;
        }
      }
    } else {
      //in the case that you start a new table block, you are allocating the current indirect block not just indirect_table_idx+1
      indirect_table_idx = indirect_table_idx -1;
    }
    
    if (bytes_written < end_bytes) {
      write_to_indirect_blocks(indirect_table_idx+1, bytes_written, end_bytes , current_in, data);
    }
  }
  /

  //copy s_block , with the final updated free block, to the disk just in case free block changed
  //NOTE: this design requires no simultaneous processes on the disk!!
  mem_ptr = mem_buffer + BLOCK_SIZE;
  memcpy(mem_ptr, (void*)&s_block, sizeof(superblock));
  return -1;
}

/*//Do not free the direct data blocks, these belong to the inode and will get overwrittenlater
  for (int i = 0; i < N_DBLOCKS; i++) {
    //write the new next to the newly freed block
    int next_free = s_block.free_block;
    mem_ptr = mem_buffer + DATA_OFFSET + current_in.dblocks[i]*BLOCK_SIZE;
    memcpy(mem_ptr, (void*)&next_free, sizeof(int));

    //update the free block header to the newly freed block
    s_block.free_block = current_in.dblocks[i];
  }*/

  /*//TODO: update child pointers based on Inode info
  //TODO: review this entire section
  for (int i = 0; i < N_DBLOCKS && children_read < new_vn->num_children; i++ ) {
      mem_ptr = new_in.dblocks[i]*BLOCK_SIZE + DATA_OFFSET + mem_buffer;
      char* mem_end = mem_ptr+BLOCK_SIZE;

      //move through the current block
      while (mem_ptr < (mem_end - sizeof(vdir_entry) + 1)) {
        table_entry = f_readdir(new_vn, mem_ptr);
        //see if you found a valid table entry
        if (table_entry->valid = 1) {
          //if we are not building the root vn
          if (parent_vn != NULL) {
            parent_vn->child_ptrs[parent_vn->num_children] = new_vn;
            parent_vn->num_children = parent_vn->num_children+1;
          }
          
          build_vnode_tree(root_vnode, NULL, table_entry->inode_idx);
         
          children_read++;
          free(table_entry);
        }
        mem_ptr = mem_ptr + sizeof(vdir_entry);
        
      }
  }*/

  //go through indirect blocks
  
  //
  for (int j = 0; j < N_IBLOCKS && children_read < new_vn->num_children; j++) {
    char* table_mem_ptr = new_in.iblocks[j]*BLOCK_SIZE+mem_buffer+INODE_OFFSET;
    char* table_mem_end = mem_ptr+BLOCK_SIZE;
    //go through the table of pointer to other blocks
    while (table_mem_ptr <table_mem_end && children_read < new_vn->num_children) {
      char* dir_table_mem_ptr;
      char* dir_table_mem_end;
      memcpy((void*)&dir_table_mem_ptr, table_mem_ptr, sizeof(int));
      dir_table_mem_end = dir_table_mem_ptr + BLOCK_SIZE;
      //go through the directory table
      while (dir_table_mem_ptr < dir_table_mem_end && children_read < new_vn->num_children) {
        table_entry = f_readdir(new_vn, dir_table_mem_ptr);
        
        //TODO: also check for nullness
        if (table_entry->valid == 1) {
          //update the number of children of a dir
          new_vn->num_children = new_vn->num_children + 1;
          children_read++;
          //recurse
          build_vnode_tree(new_vn, NULL, table_entry->inode_idx);
          //update ptr in table
        }
        
        dir_table_mem_ptr = dir_table_mem_ptr + sizeof(vdir_entry);
      }
      //update ptr in table
      table_mem_ptr = table_mem_ptr+ sizeof(int);
    }
  }


  //This is useful for checking on the inode level
          /*int children_read = 0;
           vdir_entry* table_entry = NULL;
          int idx = 0;
          printf("run ls, on dir %s with num children %d\n", refed_dir->name, refed_dir->num_children);
          while (children_read < refed_dir->num_children) {
            table_entry = f_readdir(refed_dir, idx);
            if (table_entry != 0 && table_entry->valid == 1) {
              printf("%s  \n", table_entry->name);
              children_read++;
            }
            idx++;
          }*/

          /*//TODO: remove all of this
  vdir_entry* new_table_entry;
  int num_read = 0;
  int idx = 0;

  //not needed, all of this is in f_remove which is called by delete_vnode_tree
  //set the vdir entry of the parent to be invalid
  while (num_read < parent_vn->num_children) {
    new_table_entry = f_readdir(vn, idx);
    //found a valid child entry
    if (new_table_entry != NULL && new_table_entry->valid == 1) {
      num_read++;
    }
    
    //overwrite the searched for child entry
    if (new_table_entry != NULL && strcmp(new_table_entry->name, vn->name) == 0) {
      //set the flag to invalid
      new_table_entry->valid =0;
      off_t offset = idx*sizeof(vdir_entry);
      vfd_t dir_fd = f_opendir(parent_vn, (const char*)"");
      //seek the location of the invalid entry
      f_seek(parent_vn, dir_fd, offset, SEEK_SET);
      parent_vn->size = parent_vn->size - (int)(sizeof(vdir_entry));
      //overwrite the nextry
      f_write(parent_vn, new_table_entry, sizeof(vdir_entry),1, dir_fd);
      f_closedir(parent_vn, dir_fd);
      free(new_table_entry);
      break;
    }
    free(new_table_entry);
    idx++;
  }

  //UPDATE keep size constant becuase we are setting the entry to be invalid, but update num children
  //parent_vn->size = parent_vn->size - (int)(sizeof(vdir_entry));
  parent_vn->num_children = parent_vn->num_children-1;

  //fwrite will have added to the size of the parent inode, deleting makes it clear that the vdir entry was overwritten
  inode parent_in;
  char* mem_ptr = mem_buffer +INODE_OFFSET + parent_vn->inode*BLOCK_SIZE;
  memcpy((void*)&parent_in, mem_ptr, sizeof(inode));
  parent_in.num_children = parent_in.num_children-1;
  parent_in.size = parent_in.size - (int)(sizeof(vdir_entry));
  memcpy(mem_ptr,(void*)&parent_in, sizeof(inode));*/


  Print statments:
  //printf("here now, wrote %ld info %s at idx %d\n", size, table_entry.name, idx);

        //this is to retrieve the written entry
        vdir_entry data2;
        f_seek(vn, dir_fd, data_offset, SEEK_SET);
        
        f_read(vn, (void*)&data2, sizeof(vdir_entry),1, dir_fd);
        f_closedir(vn, dir_fd);
        //printf("data of table entry: %s\n", data2.name);

        //printf("here now, wrote %ld info %s at idx %d\n", size, table_entry.name, idx);

        // //this is to retrieve the written entry
        // vdir_entry data2;
        // f_seek(vn, 0, data_offset, SEEK_SET);
        
        // f_read(vn, (void*)&data2, sizeof(vdir_entry),1, dir_fd);
        // printf("data of table entry %s\n", data2.name);

        //printf("here now, wrote %ld info %s at idx %d\n", size, original_entry.name, idx);

      //this is to retrieve the written entry
      // vdir_entry data2;
      // f_seek(new_parent_dir, 0, data_offset, SEEK_SET);
      
      // f_read(new_parent_dir, (void*)&data2, sizeof(vdir_entry),1, new_dir_fd);
      // printf("data of table entry: %s\n", data2.name);

      //printf("wrote %ld data to the inode\n", size);

      //this is to retrieve the written entry
      //TODO: remove this stuff
      vdir_entry data3;
      f_seek(vn,dir_fd, 0, SEEK_SET);
      
      f_read(vn, (void*)&data3, sizeof(vdir_entry),1, dir_fd);
      //printf("data of table entry: %s\n", data3.name);
      //to here